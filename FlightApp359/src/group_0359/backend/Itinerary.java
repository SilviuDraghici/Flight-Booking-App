package group_0359.backend;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

/**
 * An itinerary with an ordered series of 
 * flights, a total cost and a total travel 
 * time.
 * 
 * @author Mandy Li
 *
 */
public class Itinerary implements Serializable {

    /** UID generated by Eclipse. */
    private static final long serialVersionUID = -2948132465951966886L;

    /** Stores all locations that this Itinerary visits. */
    private List<String> places;
    
    /** The ordered list of Flights in this Itinerary. */
    private List<Flight> itinerary;

    /** The departure date and time of this Itinerary. */
    private DateTime departDateTime;

    /** The arrival date and time of this Itinerary. */
    private DateTime arrivalDateTime;

    /** The origin of this Itinerary. */
    private String origin;

    /** The destination of this Itinerary. */
    private String destination;

    /** The cost of this Itinerary in dollars. */
    private double price; 

    /** The travel time of this Itinerary in hours. */
    private double travelTime;

    /**
     * Creates a new Itinerary with one Flight.
     * @param flight the first Flight in the new Itinerary
     */
    public Itinerary(Flight flight) {
        
        // Initializes other instance variables for this Itinerary based
        // on the given first flight.
        this.departDateTime = flight.getDepartDateTime();
        this.arrivalDateTime = flight.getArrivalDateTime();
        this.origin = flight.getOrigin();
        this.destination = flight.getDestination();
        this.price = flight.getCost();
        this.travelTime = this.arrivalDateTime.timeDiff(this.departDateTime);
        
        // Initializes first flight for this Itinerary,
        this.itinerary = new ArrayList<Flight>();
        this.itinerary.add(flight);
        
        // Initializes places (stop over points) for this Itinerary.
        this.places = new ArrayList<String>();
        this.places.add(origin);
        this.places.add(destination);
    }

    /**
     * Creates new Itinerary that is a copy of the 
     * given Itinerary.
     * @param other the other given Itinerary from which to
     *        make a copy of the new Itinerary
     */
    public Itinerary(Itinerary other) {
        this.departDateTime = other.departDateTime;
        this.arrivalDateTime = other.arrivalDateTime;
        this.origin = other.origin;
        this.destination = other.destination;
        this.price = other.price;
        this.travelTime = other.travelTime;
        this.itinerary = new ArrayList<Flight>(other.itinerary);
        this.places = new ArrayList<String>(other.places);
    }

    /**
     * Returns the number of Flights in this Itinerary.
     * @return the number of Flights in this Itinerary
     */
    public int getNumFlights() {
        return itinerary.size();
    }

    /**
     * Returns the Flight at the given position in this 
     * Itinerary.
     * @param position the given position in this Itinerary
     * @return the Flight at the given position in this 
     *         Itinerary.
     */
    public Flight getFlight(int position) {
        return itinerary.get(position);  
    }

    /**
     * Returns the departure date and time of this Itinerary.
     * @return the departDateTime the departure date and time of 
     *         this Itinerary.
     */
    public DateTime getDepartDateTime() {
        return departDateTime;
    }

    /**
     * Returns the arrival date and time of this Itinerary.
     * @return the arrivalDateTime the arrival date and time of this Itinerary.
     */
    public DateTime getArrivalDateTime() {
        return arrivalDateTime;
    }

    /**
     * Returns the origin of this Itinerary.
     * @return the origin the origin of this Itinerary.
     */
    public String getOrigin() {
        return origin;
    }

    /**
     * Returns the destination of this Itinerary.
     * @return the destination the destination of this Itinerary.
     */
    public String getDestination() {
        return destination;
    }

    /**
     * Returns the cost of this Itinerary in dollars.
     * @return the price the cost of this Itinerary in dollars.
     */
    public double getCost() {
        return price;
    }

    /**
     * Returns the travel time of this Itinerary in hours.
     * @return the travelTime the travel time of this Itinerary in hours.
     */
    public double getTravelTime() {
        return travelTime;
    }

    /**
     * Returns the difference in hours from the arrival date and time of this
     * Itinerary to the departure date and time of the given Flight.
     * @param flight the given Flight 
     * @return the difference in hours from the arrival date and time of this
     *         itinerary to the departure date and time of the given Flight
     */
    private double getStopOverTime(Flight flight) {
        return flight.getDepartDateTime().timeDiff(arrivalDateTime);
    }

    /**
     * Returns true if the origin of the given Flight is the same as the 
     * destination of this Itinerary, if the stop over time between the
     * origin of the given Flight and the destination of this Itinerary 
     * is not below zero or over six hours, if the destination of the 
     * given Flight is not a location that this Itinerary had previously
     * visited and if the number of seats in the given Flight is greater
     * than 0. Returns false otherwise.
     * @param flight the given Flight to compare to this Itinerary
     * @return true if the origin of the given Flight is the same as the 
     *         destination of this Itinerary, if the stop over time between 
     *         the origin of the given Flight and the destination of this 
     *         Itinerary is not below zero or over six hours, if the 
     *         destination of the given Flight is not a location that this 
     *         Itinerary had previously visited, and if the number of seats
     *         in the given Flight is greater than 0.
     */
    private boolean validAdd(Flight flight) {
        double stopOverTime = getStopOverTime(flight);
        return (destination.equals(flight.getOrigin()) 
                && stopOverTime <= 6 && stopOverTime >= 0 /*= 0 creates error*/
                && !(places.contains(flight.getDestination())));
    }

    /**
     * Adds the given Flight to the end of this Itinerary
     * and updates the appropriate fields.
     * @param flight the given Flight to be added to this Itinerary
     */
    private void addFlight(Flight flight) {
        this.itinerary.add(flight);
        
        // Updates all relevant fields in this Itinerary.
        this.arrivalDateTime = flight.getArrivalDateTime();
        this.destination = flight.getDestination();
        this.travelTime = arrivalDateTime.timeDiff(departDateTime);
        this.price += flight.getCost();
        this.places.add(destination);
    }

    /**
     * Adds the next given Flight to the end of this Itinerary if the 
     * given flight is valid. Does nothing if given Flight is not
     * valid. The given Flight is valid if its origin is the same as the 
     * destination of this Itinerary, if the stop over time between its
     * origin and the destination of this Itinerary is not below zero
     * or over six hours, and if the its destination is not a location 
     * that his Itinerary had previously visited.
     * @param flight the given Flight to be added to this Itinerary
     */
    public void add(Flight flight) {
        if (validAdd(flight)) {
            addFlight(flight);
        }
    }

    /**
     * Adds all the flights in the given Itinerary to the
     * tail of this Itinerary.
     * @param other the given Itinerary to be added to this 
     *        Itinerary
     */
    public void add(Itinerary other) {   
        List<Flight> otherItinerary = other.itinerary;
        if (validAdd(otherItinerary.get(0))) {
            for (Flight flight: otherItinerary) {
                addFlight(flight);
            }
        }
    }

    /**
     * Removes the last Flight in this Itinerary.
     * Does nothing if there is only one Flight in this
     * Itinerary.
     */
    public void remove() {
        int size = itinerary.size();
        if (size != 1) {
            
            // Removes last Flight in this Itinerary.
            Flight removedFlight = this.itinerary.remove(size - 1);
            
            // Gets the new last Flight in this Itinerary.
            Flight flight = this.itinerary.get(size - 2);
            
            // Updates all the relevant fields in this Itinerary.
            this.price -= removedFlight.getCost();
            this.arrivalDateTime = flight.getArrivalDateTime();
            this.destination = flight.getDestination();
            this.travelTime = arrivalDateTime.timeDiff(departDateTime);
            this.places.remove(size);
        }
    }
    
    /**
     * Returns true if this Itinerary is bookable.
     * @return true if this Itinerary is bookable.
     */
    public boolean bookable() {
        for (Flight flight : itinerary) {
            if (flight.getNumSeats() <= 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the string representation of this Itinerary 
     * where each line of Flight in this Itinerary is in the format,
     * "Number,DepartureDateTime,ArrivalDateTime,Airline,Origin,Destination"
     * followed by a the total cost and the total time traveled of this 
     * Itinerary, each in their own line. The total time traveled is in
     * HH:MM format.
     */
    @Override
    public String toString() {
        String output = new String();
        for (Flight flight : itinerary) {
            output += flight.toStringWithoutCost() + "\n";
        }

        // Gets output of two decimal places from cost.
        double cost = Math.round(price * 100) / 100.0;
        
        return (output + String.format("%.2f", cost) + "\n" 
                + DateTime.hoursToString(travelTime));
    }

    /**
     * Returns all the places visited by this Itinerary.
     * @return a list of all the places visited by this Itinerary.
     */
	public List<String> getPlaces() {
		return places;
	}
}

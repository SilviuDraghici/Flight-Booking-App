package group_0359.backend;

import java.io.Serializable;

/**
 * A date and time with a year, month, day, hour 
 * and minute value. It is immutable. Contains static 
 * methods to convert between the number of hours and a 
 * string format, "HH:MM", showing the number of hours.
 * 
 * @author Mandy Li
 *
 */
public final class DateTime implements Comparable<DateTime>, Serializable {

    /** UID generated by Eclipse */
    private static final long serialVersionUID = -3812119426591308538L;

    /** The number of hours in a single day. */
    private static final int HOURS_DAY = 24;

    /** The number of hours in a single minute. */
    private static final double HOURS_MINUTE = 1.0/60.0;

    /** The maximum number of months in a single year. */
    private static final int MAX_MONTH = 12;

    /** The year value of this DateTime between 1-9999. */
    private final int year;

    // Note: this month value corresponds with the
    // index value in daysInMonth that holds the
    // number of days stored per month.
    /** The month value of this DateTime between 0-11. */
    private final int month;

    /** 
     * The day value of this DateTime within values that
     * depends on the month and year.
     */
    private final int day;

    /** The hour value of this DateTime between 0-23. */
    private final int hour;

    /** The minute value of this DateTime between 0-59. */
    private final int minute;

    /** The date value of this DateTime, in YYYY-MM-DD format. */
    private final String date;  

    /** The time value of this DateTime, in HH:MM format */
    private final String time;  

    /** Stores the number of days per month for the year of this DateTime. */
    private final int[] daysInMonth;

    /**
     * Creates a new DateTime with the given year, month, day,
     * hour and minute value.
     * @param year the year value of the new DateTime
     * @param month the month value of the new DateTime
     * @param day the day value of the new DateTime
     * @param hour the hour value of the new DateTime
     * @param minute the minute value of the new DateTime
     */
    public DateTime(int year, int month, int day, int hour, int minute) {
        this.date = getDateFormatted(year, month, day);
        this.time = getTimeFormatted(hour, minute);
        this.year = year;
        this.month = month - 1;
        this.day = day;
        this.hour = hour;
        this.minute = minute;
        this.daysInMonth = getDaysInMonth(year);
    }

    /**
     * Creates a new DateTime with the given date and time.
     * @param date the date of the new DateTime, in YYYY-MM-DD format
     * @param time the time of the new DateTime, in HH:MM format
     */
    public DateTime(String date, String time) {
        this(Integer.parseInt(date.substring(0, 4)), 
                Integer.parseInt(date.substring(5, 7)),
                Integer.parseInt(date.substring(8, 10)),
                Integer.parseInt(time.substring(0, 2)),
                Integer.parseInt(time.substring(3)));
    }

    /**
     * Creates a new DateTime with the given date and time.
     * @param dateTime the date and time of the new DateTime, 
     *        in YYYY-MM-DD HH:MM format.
     */
    public DateTime(String dateTime) {
        this(dateTime.substring(0, 10), dateTime.substring(11));
    }

    /**
     * Returns true if the given values for year, month and day
     * makes a valid date.
     * @param year the given year value of the date
     * @param month the given month of value the date
     * @param day the given day value of the date
     * @return true if the given values for year, month and day
     *         makes a valid date.
     */
    public static boolean validDate(int year, int month, int day) {
        return (withinRange(1, 9999, year) && withinRange(1, 12, month) 
                && withinRange(0, getDaysInMonth(year)[month - 1], day));
    }

    /**
     * Returns true if the given values for hour and 
     * minute makes a valid time.
     * @param hour the given hour of the time
     * @param minute the given minute of the time
     * @return true if the given values for hour and 
     *         minute makes a valid time.
     */
    public static boolean validTime(int hour, int minute) {
        return (withinRange(0, 23, hour) && withinRange(0, 59, minute));
    }

    /**
     * Returns the string representation of the time with the
     * given hour and minute values in HH:MM format.
     * @param hour the given hour value to get the string 
     *        representation of the time
     * @param minute the given minute value to get the string
     *        representation of the time
     * @return a string representation of the time with the
     *         given hour and minute values in HH:MM format.
     */
    public static String getTimeFormatted(int hour, int minute) {
        return (String.format("%02d", hour) 
                + ":" + String.format("%02d", minute));
    }

    /**
     * Returns the string representation of a date with the
     * given year, month and day values in YYYY-MM-DD format.
     * @param year the given year value to get the string 
     *        representation of the date
     * @param month the given month value to get the string
     *        representation of the date
     * @param day the given day value to get the string 
     *        representation of the date
     * @return a string representation of a date with the
     *         given year, month and day values in YYYY-MM-DD format.
     */
    public static String getDateFormatted(int year, int month, int day) {
        return (String.format("%04d", year) 
                + "-" + String.format("%02d", month) 
                + "-" + String.format("%02d", day));
    }

    /**
     * Returns true of the given integer is greater than or equal
     * to the given maximum integer and less than or equal to the
     * given minimum integer.
     * @param min the given minimum integer to compare to the given
     *        integer
     * @param max the given maximum integer to compare to the given
     *        integer
     * @param integer the given integer to compare to the given
     *        maximum and minimum integer
     * @return true of the given integer is greater than or equal
     *         to the given maximum integer and less than or equal to the
     *         given minimum integer.
     */
    private static boolean withinRange(int min, int max, int integer) {
        return (integer >= min && integer <= max);
    }

    /**
     * Returns true if the given year is a leap year.
     * @param year the given year to check if it is a
     *        leap year
     * @return true if the given year is a leap year.
     */
    private static boolean isLeapYear(int year) {
        return (year % 400 == 0 || year % 4 == 0 && year % 100 != 0);
    }

    /**
     * Returns an array of integers of size MAX_MONTHS 
     * holding the number of days in each respective 
     * month in the given year.
     * @param year the given year from which to obtain the
     *        number of days in each month.
     * @return an array of integers of size MAX_MONTHS 
     *         holding the number of days in each respective 
     *         month in the given year.
     */
    private static int[] getDaysInMonth(int year) {
        int[] output = new int[MAX_MONTH];
        if (isLeapYear(year)) {
            output[1] = 29;  // February
        } else {
            output[1] = 28;  // February
        }
        output[0] = 31;      // January
        output[2] = 31;      // March
        output[3] = 30;      // April
        output[4] = 31;      // May
        output[5] = 30;      // June
        output[6] = 31;      // July
        output[7] = 31;      // August
        output[8] = 30;      // September
        output[9] = 31;      // October
        output[10] = 30;     // November
        output[11] = 31;     // December
        return output;
    }

    /**
     * Returns the difference in number of days from the
     * given DateTime to this DateTime. Returns a negative
     * number of days if this DataTime is before the given
     * DateTime.
     * @param dateTime the given DateTime from which to obtain
     *        the difference in days to this DateTime
     * @return the difference in number of days from the
     *         given DateTime to this DateTime. Returns a negative
     *         number of days if this DataTime is before the given
     *         DateTime.
     */
    private int daysDiff(DateTime dateTime) {

        // Holds the return value.
        int diff = 0;

        // Sets the increments of diff, which depends on
        // whether diff becomes more negative or more 
        // position when moving from the month of this
        // DateTime to the month of the given DateTime.
        int increment;
        int monthLimit;
        int nextMonth;
        if (this.compareTo(dateTime) > 0) {
            monthLimit = MAX_MONTH - 1;
            nextMonth = 0; 
            increment = 1;

            // Calculates difference in number of days between
            // between the day of the month for the given DateTime
            // and the day of the month for this DateTime if this
            // DateTime comes after the given DateTime.
            diff += ((dateTime.daysInMonth[dateTime.month] - dateTime.day)
                    - (daysInMonth[month] - day));
        } else {
            increment = -1;
            monthLimit = 0;
            nextMonth = MAX_MONTH - 1; 

            // Calculates difference in number of days between
            // between the day of the month for the given DateTime
            // and the day of the month for this DateTime if this
            // DateTime comes before the given DateTime. This will
            // be a negative number.
            diff += day - dateTime.day;
        }

        // Adds the respective number of days in each
        // month of each year to the diff variable 
        // from the given month in the given DateTime
        // to the current current in DateTime
        int currYear = dateTime.year;
        int currMonth = dateTime.month;
        int[] currDaysInMonth = dateTime.daysInMonth;
        while (currMonth != month || currYear != year) {

            // Once the last month of the year has
            // been reached, start looking at the 
            // first month of the next year (different
            // depending on whether the given DateTime
            // comes before or after this DateTime.
            if (currMonth == monthLimit) {
                currMonth = nextMonth;
                currYear += increment;
                currDaysInMonth = getDaysInMonth(currYear);
            } else {
                currMonth += increment;
            }
            diff += currDaysInMonth[currMonth] * increment;
        }
        return diff;
    }

    /**
     * Returns the difference in hours between this DateTime and the 
     * given DateTime. The return is negative if this DateTime is
     * earlier than the given DateTime.
     * @param dateTime the given DateTime from which to obtain the 
     *        difference in number of hours to this DateTime
     * @return the difference in hours between this DateTime and the
     *         given DateTime. The return is negative if this DateTime
     *         is earlier than the given DateTime.
     */
    public double timeDiff(DateTime dateTime) {
        return (daysDiff(dateTime) * HOURS_DAY 
                + (hour - dateTime.hour)
                + (minute - dateTime.minute) * HOURS_MINUTE);
    }

    /**
     * Returns the string representation of the date of
     * this DateTime, in YYYY-MM-DD format.
     * @return the string representation of the date of
     *         this DateTime, in YYYY-MM-DD format.
     */
    public String getDate() {
        return date;
    }

    /**
     * Returns the string representation of the time of 
     * this DateTime, in HH:MM format.
     * @return the the string representation of the time of
     *         this DateTime, in HH:MM format.
     */
    public String getTime() {
        return time;
    }

    /**
     * Returns true if the date of this DateTime is the
     * same as the date of the given DateTime. 
     * Returns false otherwise.
     * @param dateTime the given DateTime from which to compare
     *        the date to this DateTime
     * @return true if the date of this DateTime is the same as 
     *         the date of the given DateTime. Returns false
     *         otherwise.
     */
    public boolean isSameDate(DateTime dateTime) {
        return date.equals(dateTime.date);
    }

    /**
     * Returns a string representation of the given 
     * number of hours, in HH:MM format.
     * @param numHours the given number of hours from
     *        which to obtain a string representation,
     *        in HH:MM format
     * @return a string representation of the given
     *         number of hours, in HH:MM format.
     */
    public static String hoursToString(double numHours) {

        // Hour value is rounded down.
        int hours = (int) numHours;

        // Minute value is obtained from the remaining hours
        // (less than 1 hour) and is rounded up.
        int minutes = (int) Math.round(((numHours - hours) / HOURS_MINUTE));

        // Appends appropriate leading zeroes depending
        // on whether the hour value would is going to be
        // over characters or not. If over two characters,
        // turn hours into string directly. Otherwise, 
        // appends leading zeros and get the 2 character
        // string representation of the hour value.
        String hr;
        if (hours > 99) {
            hr = Integer.toString(hours);
        } else {
            hr = "00" + Integer.toString(hours);
            hr = hr.substring(hr.length() - 2);
        }

        // Appends appropriate leading zeroes in case
        // minute value is under two digits.
        String min = "00" + Integer.toString(minutes);

        // Returns minute value in 2 characters and hour
        // value with a minimum of 2 characters.
        return hr  + ":" + min.substring(min.length() - 2);
    }

    /**
     * Returns the decimal equivalent of the given number 
     * of hours, in HH:MM format.
     * @param numHours the given number of hours,
     *        in HH:MM format
     * @return the decimal equivalent of the given number of 
     *         hours, in HH:MM format.
     */
    public static double stringToHours(String numHours) {
        String[] hourParts = numHours.split(":");
        int hours = Integer.parseInt(hourParts[0]);
        int minutes = Integer.parseInt(hourParts[1]);

        return hours + minutes * HOURS_MINUTE;
    }

    /**
     * Returns the DateTime obtained adding 6 hours to
     * this DateTime.
     * @return the DateTime obtained from adding 6 hours 
     *         to this DateTime
     */
    public DateTime offsetDate(){

        DateTime dateTime = this;

        //If past 6, then change date along with time
        if(hour>=18){

            //New date
            String newDay = (day + 1) + "";

            //If day of date was in {1,2,3,4,5,6,7,8,9} format accordingly.
            if(Math.floor(day+1/10) == 0){
                newDay = "0" + (day+1);
            }

            //Add new day to date. Will change again if 28,29,30,31
            String date = getDate().substring(0, 8) + newDay;

            //Checks if end of the month or year. And changes date accordingly
            switch(day){

            //If February and not leap year.
            case 28: if((month == 1) && (year%4 != 0)){

                date = year + "-" + "03" + "-" + "01";

            }
            break;

            //If February and leap year
            case 29: if(month == 1){

                date = year + "-" + "03" + "-" + "01";

            }
            break;

            //If month ends on the 30th
            case 30: int[] endIn30 = {3,5,8,10};   					
            for(int i: endIn30){ 
                if(i == month){

                    if((i == 3) || (i == 5)){
                        date = year + "-" + "0" + (i+2)
                                + "-"+ "01" ;
                    }
                    else{
                        date = year + "-" + (i+1) + "-" 
                                + "01";
                    }
                    break;
                }
            }
            break;

            //If month ends on the 31st
            case 31: if(month == 0 || month == 2 || month == 7){
                date = year + "-" + "0" + (month+1)
                        + "-"+ "01" ;
            }
            else if(month == 9){

                date = year + "-" + "11" + "-" 
                        + "01";
            }
            else{
                date = (year+1) + "-" + "01" + "-" 
                        + "01";
            }
            }

            //New time after date change.
            String newTime = "0" + hour%6 + getTime().substring(2); 

            //Creates new DateTime according to changes.
            dateTime = new DateTime(date,newTime);
        }

        //If don't need to change date
        if(hour<=17 && minute<=59){

            //New time after 6 hours.
            String newTime = null;
            int newHour = hour + 6;

            //If new hour in {6,7,8,9}, formats accordingly.
            if(Math.floor(newHour/10) == 0){
                newTime = "0" + newHour + getTime().substring(2);
            }
            else{
                newTime = newHour + getTime().substring(2);
            }

            //returns DateTime with changed hours
            return new DateTime(this.getDate(),newTime);
        }



        return dateTime;
    }

    /**
     * Returns a positive number if this DateTime comes
     * after the given DateTime. Returns zero if this 
     * DateTime is the same as the given DateTime. 
     * Returns a negative number otherwise.
     *@param dateTime the DateTime to compare to this 
     *       DateTime.
     */
    @Override
    public int compareTo(DateTime dateTime) {
        int diff = 0;
        diff = year - dateTime.year;
        if (diff != 0) {
            return diff;
        }
        diff = month - dateTime.month;
        if (diff != 0) {
            return diff;
        }
        diff = day - dateTime.day;
        if (diff != 0) {
            return diff;
        }
        diff = hour - dateTime.hour;
        if (diff != 0) {
            return diff;
        }
        diff = minute - dateTime.minute;
        if (diff != 0) {
            return diff;
        }
        return diff;
    }

    
    /**
     * Returns the year value of this DateTime.
     * @return the year value of this DateTime.
     */
    public int getYear() {
        return year;
    }

    /**
     * Returns the month value of this DateTime
     * between 1-12.
     * @return the month value of this DateTime.
     */
    public int getMonth() {
        return month + 1;
    }

    /**
     * Returns the day value of this DateTime..
     * @return the day value of this DateTime.
     */
    public int getDay() {
        return day;
    }

    /**
     * Returns the hour value of this DateTime.
     * @return the hour value of this DateTime.
     */
    public int getHour() {
        return hour;
    }

    /**
     * Returns the minute value of this DateTime.
     * @return the minute value of this DateTime.
     */
    public int getMinute() {
        return minute;
    }

    /**
     * Returns the string representation of this DateTime,
     * in YYYY-MM-DD HH:MM format
     */
    @Override
    public String toString() {
        return date + " " + time;
    }
}
